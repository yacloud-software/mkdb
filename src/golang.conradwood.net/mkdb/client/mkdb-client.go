package main

import (
	"flag"
	"fmt"
	"github.com/emicklei/proto"
	"golang.conradwood.net/apis/mkdb"
	"golang.conradwood.net/go-easyops/authremote"
	//	"golang.conradwood.net/go-easyops/client"
	"golang.conradwood.net/go-easyops/utils"
	"golang.conradwood.net/mkdb/lib"
	"golang.conradwood.net/mkdb/linux"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var (
	ip          = flag.String("importpath", "", "importpath of the proto file")
	pkg         = flag.String("package", "main", "packagename to use...")
	proto_file  = flag.String("protofile", "", "filename of a .proto to parse and databaseize")
	messages    = flag.Bool("messages", false, "get all messages in proto file")
	dbfile      = flag.Bool("create", false, "create a .go file with DB access functions (requires -protobuf)")
	message     = flag.String("protobuf", "", "the name of the protobuf to render into db access functions")
	out         = flag.String("out", "", "file to (over)write. default: stdout")
	idfield     = flag.String("idfield", "", "instead of autodetect, use a field by name as the unique primary key")
	tablename   = flag.String("table", "", "name of table to use. Default: autogenerated")
	tableprefix = flag.String("tableprefix", "", "prefix to prepend to tablename")
	use_stream  = flag.Bool("m", true, "generate multiple files")
	mclient     mkdb.MKDBClient
	creator     *lib.Creator
)

func main() {
	flag.Parse()

	mclient = mkdb.GetMKDBClient()

	if *proto_file == "" {
		fmt.Printf("Missing -protofile\n")
		os.Exit(10)
	}
	content, err := ioutil.ReadFile(*proto_file)
	utils.Bail("failed to read file", err)
	if *messages {
		ctx := authremote.Context()
		msgs, err := mclient.GetMessages(ctx, &mkdb.GetMessagesRequest{ProtoFile: string(content)})
		utils.Bail("failed to get messages", err)
		for _, m := range msgs.Messages {
			fmt.Printf("%v\n", m)
		}
	} else if *dbfile {
		if *use_stream {
			utils.Bail("failed to create", MultipleFiles(content))
		} else {
			utils.Bail("failed to create file", singleFile(content))
		}
	} else {
		fmt.Printf("Nothing to do!\n")
		os.Exit(10)
	}

}

// content is the proto file we are reading from
func MultipleFiles(content []byte) error {
	dir := *out
	if utils.FileExists(dir) {
		st, err := os.Stat(dir)
		if err != nil {
			return err
		}
		if !st.IsDir() {
			dir = filepath.Dir(dir)
		}
	} else {
		if strings.HasSuffix(dir, ".go") {
			dir = filepath.Dir(dir)
		}
		if !utils.FileExists(dir) {
			return fmt.Errorf("target directory \"%s\" does not exist", dir)
		}
		st, err := os.Stat(dir)
		if err != nil {
			return err
		}
		if !st.IsDir() {
			return fmt.Errorf("target \"%s\" is not a directory", dir)
		}
	}

	os.MkdirAll(dir, 0777)
	fmt.Printf("Writing files to %s\n", dir)

	ctx := authremote.Context()
	cr := &mkdb.CreateDBRequest{
		ProtoFileName: *proto_file,
		ImportPath:    *ip,
		ProtoFile:     string(content),
		Message:       *message,
		IDField:       *idfield,
		TableName:     *tablename,
		TablePrefix:   *tableprefix,
	}
	srv, err := mclient.CreateDBFiles(ctx, cr)
	if err != nil {
		return err
	}
	new_content := make(map[string][]byte) // filename->content
	for {
		msg, err := srv.Recv()
		if msg != nil {
			fname := msg.Filename
			cs := new_content[fname]
			cs = append(cs, msg.Data...)
			new_content[fname] = cs
		}
		if err == io.EOF {
			break
		}
	}
	for filename, content := range new_content {
		fname := dir + "/" + filename
		err = utils.WriteFile(fname, content)
		if err != nil {
			return err
		}
		fmt.Printf("Written %s\n", fname)
	}
	return nil
}
func singleFile(content []byte) error {
	ctx := authremote.Context()
	cr := &mkdb.CreateDBRequest{
		ProtoFileName: *proto_file,
		ImportPath:    *ip,
		ProtoFile:     string(content),
		Message:       *message,
		IDField:       *idfield,
		TableName:     *tablename,
		TablePrefix:   *tableprefix,
	}
	msgs, err := mclient.CreateDBFile(ctx, cr)
	if err != nil {
		return err
	}
	if *out == "" {
		fmt.Printf("%s\n", msgs.GoFile)
	} else {
		err := ioutil.WriteFile(*out, []byte(msgs.GoFile), 0644)
		if err != nil {
			return err
		}
		fmt.Printf("GoFile Written to %s\n", *out)
	}
	return nil
}

// only left here as reference...
func stupid() {
	creator = lib.NewCreator()
	creator.Pkgname = *pkg
	def := mkdb.ProtoDef{
		ImportPath: "golang.conradwood.net/apis/authrequests",
		Name:       "Measurement",
		Fields: []*mkdb.ProtoField{
			&mkdb.ProtoField{Name: "SensorLocationID", Type: 1}, // primary id
			&mkdb.ProtoField{Name: "Value", Type: 2},            // double
			&mkdb.ProtoField{Name: "Timestamp", Type: 3},        // uint32
		},
	}
	err := creator.CreateByDef(&def)
	creator.Pkgname = *pkg
	utils.Bail("failed to create by def", err)
	fmt.Println(creator.DBGo())
}

func dofile(filename string) {
	reader, _ := os.Open(filename)
	defer reader.Close()

	parser := proto.NewParser(reader)
	definition, err := parser.Parse()
	utils.Bail("failed to parse file", err)

	proto.Walk(definition,
		proto.WithService(handleService),
		proto.WithMessage(handleMessage))
}

func handleService(s *proto.Service) {
	//	fmt.Println(s.Name)
}

func handleMessage(m *proto.Message) {
	def := mkdb.ProtoDef{
		ImportPath: "golang.conradwood.net/apis/authrequests",
		Name:       m.Name,
	}
	fmt.Printf("%s\n", m.Name)
	for _, e := range m.Elements {
		x, ok := e.(*proto.NormalField)
		if !ok {
			continue
		}
		t := lib.From_go_string(x.Type)
		if strings.ToLower(x.Name) == "id" {
			t = 1 // primary id
		}
		if t == 0 {
			fmt.Printf("   unknown type: %s %s\n", x.Name, x.Type)
			continue
		}
		pf := &mkdb.ProtoField{Name: x.Name, Type: t}
		def.Fields = append(def.Fields, pf)

		fmt.Printf("   %s %s (%d)\n", x.Name, x.Type, t)
	}
	fmt.Printf("   %d fields\n", len(def.Fields))
	creator := lib.NewCreator()
	creator.Pkgname = *pkg
	creator.Structname = fmt.Sprintf("DB%s", m.Name)
	creator.TableName = strings.ToLower(m.Name)
	err := creator.CreateByDef(&def)
	utils.Bail("failed to create by def", err)
	fname := fmt.Sprintf("/tmp/x/db-%s.go", m.Name)
	err = ioutil.WriteFile(fname, []byte(creator.DBGo()), 0777)
	utils.Bail("failed to write file", err)
	linux.SafelyExecute([]string{"gofmt", "-w", fname}, nil)

}
